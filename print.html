<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sui Kiosk</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what-is-sui-kiosk.html"><strong aria-hidden="true">1.</strong> What is Sui Kiosk</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="philosophy.html"><strong aria-hidden="true">2.1.</strong> Philosophy</a></li><li class="chapter-item expanded "><a href="guarantees.html"><strong aria-hidden="true">2.2.</strong> Guarantees</a></li><li class="chapter-item expanded "><a href="roles/index.html"><strong aria-hidden="true">2.3.</strong> Roles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="roles/kiosk-owner.html"><strong aria-hidden="true">2.3.1.</strong> Kiosk Owner (Seller)</a></li><li class="chapter-item expanded "><a href="roles/creator.html"><strong aria-hidden="true">2.3.2.</strong> Creator</a></li><li class="chapter-item expanded "><a href="roles/buyer.html"><strong aria-hidden="true">2.3.3.</strong> Buyer</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="transfer-policy/index.html"><strong aria-hidden="true">3.</strong> Transfer Policy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transfer-policy/rules.html"><strong aria-hidden="true">3.1.</strong> Rules</a></li><li class="chapter-item expanded "><a href="transfer-policy/writing-rules.html"><strong aria-hidden="true">3.2.</strong> Writing Rules</a></li><li class="chapter-item expanded "><a href="transfer-policy/multiple-transfer-policies.html"><strong aria-hidden="true">3.3.</strong> Multiple Transfer Policies</a></li></ol></li><li class="chapter-item expanded "><a href="kiosk/index.html"><strong aria-hidden="true">4.</strong> Kiosk</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kiosk/create.html"><strong aria-hidden="true">4.1.</strong> &quot;Open a Kiosk&quot;</a></li><li class="chapter-item expanded "><a href="kiosk/place-and-take.html"><strong aria-hidden="true">4.2.</strong> Place and Take</a></li><li class="chapter-item expanded "><a href="kiosk/locking.html"><strong aria-hidden="true">4.3.</strong> Locking</a></li><li class="chapter-item expanded "><a href="kiosk/list-and-purchase.html"><strong aria-hidden="true">4.4.</strong> List and Purchase</a></li><li class="chapter-item expanded "><a href="kiosk/borrowing.html"><strong aria-hidden="true">4.5.</strong> Borrowing</a></li><li class="chapter-item expanded "><a href="kiosk/withdrawing-profits.html"><strong aria-hidden="true">4.6.</strong> Withdrawing Profits</a></li><li class="chapter-item expanded "><a href="kiosk/purchase-cap.html"><strong aria-hidden="true">4.7.</strong> Custom trading with PurchaseCap</a></li><li class="chapter-item expanded "><a href="kiosk/purchase-cap-tricks.html"><strong aria-hidden="true">4.8.</strong> PurchaseCap tricks</a></li><li class="chapter-item expanded "><a href="kiosk/extensions.html"><strong aria-hidden="true">4.9.</strong> Extensions</a></li></ol></li><li class="chapter-item expanded "><a href="kiosk-extensions/index.html"><strong aria-hidden="true">5.</strong> Kiosk Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kiosk-extensions/simple-extensions.html"><strong aria-hidden="true">5.1.</strong> Simple Extensions</a></li><li class="chapter-item expanded "><a href="kiosk-extensions/extensions-api/index.html"><strong aria-hidden="true">5.2.</strong> Extensions API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kiosk-extensions/extensions-api/adding-an-extension.html"><strong aria-hidden="true">5.2.1.</strong> Adding an Extension</a></li><li class="chapter-item expanded "><a href="kiosk-extensions/extensions-api/extension-permissions.html"><strong aria-hidden="true">5.2.2.</strong> Extension Permissions</a></li><li class="chapter-item expanded "><a href="kiosk-extensions/extensions-api/extension-storage.html"><strong aria-hidden="true">5.2.3.</strong> Extension Storage</a></li><li class="chapter-item expanded "><a href="kiosk-extensions/extensions-api/disabling-and-removing.html"><strong aria-hidden="true">5.2.4.</strong> Disabling and Removing</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="building-with-kiosk/index.html"><strong aria-hidden="true">6.</strong> Building with Kiosk</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-with-kiosk/indexing-events.html"><strong aria-hidden="true">6.1.</strong> Indexing Events</a></li><li class="chapter-item expanded "><a href="building-with-kiosk/using-kiosk-in-a-module.html"><strong aria-hidden="true">6.2.</strong> Using Kiosk in a Module</a></li><li class="chapter-item expanded "><a href="building-with-kiosk/custom-event-handlers-in-extensions.html"><strong aria-hidden="true">6.3.</strong> Custom Event handlers in Extensions</a></li><li class="chapter-item expanded "><a href="building-with-kiosk/demo-applications.html"><strong aria-hidden="true">6.4.</strong> Demo Applications</a></li></ol></li><li class="chapter-item expanded "><a href="mysten-kiosk/index.html"><strong aria-hidden="true">7.</strong> Mysten Kiosk</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mysten-kiosk/extensions/index.html"><strong aria-hidden="true">7.1.</strong> Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mysten-kiosk/extensions/personal-kiosk.html"><strong aria-hidden="true">7.1.1.</strong> Personal Kiosk</a></li></ol></li><li class="chapter-item expanded "><a href="mysten-kiosk/rules/index.html"><strong aria-hidden="true">7.2.</strong> Rules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mysten-kiosk/rules/royalty-rule.html"><strong aria-hidden="true">7.2.1.</strong> Royalty Rule</a></li><li class="chapter-item expanded "><a href="mysten-kiosk/rules/kiosk-lock-rule.html"><strong aria-hidden="true">7.2.2.</strong> Kiosk Lock Rule</a></li><li class="chapter-item expanded "><a href="mysten-kiosk/rules/personal-kiosk.html"><strong aria-hidden="true">7.2.3.</strong> Personal Kiosk Rule</a></li><li class="chapter-item expanded "><a href="mysten-kiosk/rules/witness-rule.html"><strong aria-hidden="true">7.2.4.</strong> Witness Rule</a></li><li class="chapter-item expanded "><a href="mysten-kiosk/rules/floor-price-rule.html"><strong aria-hidden="true">7.2.5.</strong> Floor Price Rule</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">8.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">8.1.</strong> A - Glossary</a></li><li class="chapter-item expanded "><a href="appendix/asset-states-in-kiosk.html"><strong aria-hidden="true">8.2.</strong> B - Asset States in Kiosk</a></li><li class="chapter-item expanded "><a href="appendix/extension-states.html"><strong aria-hidden="true">8.3.</strong> C - Extension States</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Sui Kiosk</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-sui-kiosk" id="what-is-sui-kiosk">What is Sui Kiosk</a></h1>
<p>Kiosk is type defined in the <code>kiosk</code> module in the <a href="https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework">Sui Framework</a> package.</p>
<p>Key points:</p>
<ol>
<li>Kiosk is a decentralized solution</li>
<li>Gives access to global on-chain liquidity</li>
<li>Provides safety guarantees for Kiosk owners</li>
<li>Allows creators to control all trades and fees</li>
<li>Helps marketplaces index and monetize discovery of assets</li>
</ol>
<h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<h1><a class="header" href="#philosophy" id="philosophy">Philosophy</a></h1>
<p>We believe in </p>
<h1><a class="header" href="#guarantees" id="guarantees">Guarantees</a></h1>
<p>The system comes with a set of guarantees that are enforced by the smart contracts. These guarantees
are:</p>
<ol>
<li>
<p>Every trade operation in the <a href="./kiosk/README.html">Kiosk</a> requires a
<a href="./transfer-policy/README.html">TransferPolicy</a> resolution giving creators control over how their
assets are traded.</p>
</li>
<li>
<p>&quot;True Ownership&quot; - Kiosk Owner is the only party that can take, list, borrow and modify assets in
their Kiosk. No other party can do this. Similarly to how single owner objects work on Sui.</p>
</li>
<li>
<p>Strong Policy (eg Royalty) enforcement is an option for creators which can be enabled or disabled
at any time affecting all trades on the platform.</p>
</li>
<li>
<p>Changes to the TransferPolicy are instant and global.</p>
</li>
</ol>
<!-- 4. Shared Liquidity - Kiosks  -->
<hr />
<p>Practical set of guarantees:</p>
<ol>
<li>
<p>While an item is traded, it can not be modified or taken.</p>
</li>
<li>
<p>While PurchaseCap exists, an item is locked and can not be taken or modified unless the PCap is
returned or used to perform a trade.</p>
</li>
<li>
<p>Any Rule can be removed at any time.</p>
</li>
<li>
<p>Any extension can be disabled at any time.</p>
</li>
<li>
<p>Extension state is always accessible to the extension.</p>
</li>
</ol>
<h1><a class="header" href="#roles" id="roles">Roles</a></h1>
<p>As an ecosystem Kiosk defines 3 major roles and sets the rules of interaction between them. The roles are: <strong>Creator</strong>, <strong>Kiosk Owner</strong>, and <strong>Buyer</strong>. Each of the roles has a set of advantages and limitations - the former is the available functionality and the latter is the set of constraints that allows other roles to function.</p>
<p>In this section we go through all of the roles in detail and describe their interactions.</p>
<h1><a class="header" href="#kiosk-owner" id="kiosk-owner">Kiosk Owner</a></h1>
<p>Anyone on the network can create a Kiosk and use it to store and trade assets. The Kiosk Owner is the owner of the <code>KioskOwnerCap</code> - a special object that grants full access to a single Kiosk.</p>
<p>Kiosk Owner can:</p>
<ul>
<li><a href="roles/./../kiosk/place-and-take.html">Place and take items</a></li>
<li><a href="roles/./../kiosk/list-and-purchase.html">List items for sale</a></li>
<li><a href="roles/./../kiosk-extensions/">Add and remove Extensions</a></li>
<li><a href="roles/./../kiosk/withdrawing-profits.html">Withdraw profits from sales</a></li>
<li><a href="roles/./../kiosk/borrowing.html">Borrow and mutate owned assets</a></li>
<li>Access full arsenal of trading tools (eg auctions, lotteries, collection bidding etc)</li>
</ul>
<p>Kiosk provides a set of guarantees to the Kiosk Owner:</p>
<ul>
<li><strong>Safety</strong> - no other party can access items or profits stored in the Kiosk</li>
<li><strong>Liquidity</strong> - the Kiosk can be used to trade assets globally on the network</li>
<li><strong>Ownership</strong> - traded items never leave the Kiosk and are owned by the Kiosk Owner until the sale is complete</li>
</ul>
<h1><a class="header" href="#creator" id="creator">Creator</a></h1>
<p>Creator is a party that creates and controls the <a href="roles/./../transfer-policy/README.html">TransferPolicy</a> for a single type. For example, the authors of SuiFrens are the Creators of the <code>SuiFren&lt;Capy&gt;</code> type and act as creators in the Kiosk ecosystem. Creators set the policy, but they may also be the first sellers of their assets through a Kiosk.</p>
<p>Creator can:</p>
<ul>
<li><a href="roles/./../transfer-policy/rules.html">Set any rules for trades</a></li>
<li><a href="roles/./../transfer-policy/multiple-transfer-policies.html">Set multiple ways (&quot;tracks&quot;) of rules</a></li>
<li>Enable or disable trades at any moment with a policy</li>
<li>Enforce policies (eg royalties) on all trades</li>
<li>Perform a primary sale of their assets through a Kiosk</li>
</ul>
<blockquote>
<p>All of the above is effective immediately and globally.</p>
</blockquote>
<p>Creator can not:</p>
<ul>
<li>Take or modify items stored in someone else's Kiosk</li>
<li>Restrict <a href="roles/./../kiosk/place-and-take.html">taking</a> items from Kiosks if the &quot;locking&quot; rule was not set in the policy</li>
</ul>
<h1><a class="header" href="#buyer" id="buyer">Buyer</a></h1>
<p>Buyer is a party that purchases (or - more general - <em>receives</em>) items from Kiosks, anyone on the network can be a Buyer (and, for example, a Kiosk Owner at the same time).</p>
<p>Benefits:</p>
<ul>
<li>Buyers get access to global liquidity and can get the best offer</li>
<li>Buyers can place bids on collections through their Kiosks</li>
<li>Most of the actions performed in Kiosks are free (gas-less) for Buyers</li>
</ul>
<p>Responsibilities:</p>
<ul>
<li>Buyer is the party that pays the fees if they're set in the policy</li>
<li>Buyer must follow the rules set by creators or a transaction won't succeed</li>
</ul>
<p>Guarantees:</p>
<ul>
<li>When using a custom trading logic such as an Auction, the items are guaranteed to be unchanged until the trade is complete</li>
</ul>
<h1><a class="header" href="#transfer-policy" id="transfer-policy">Transfer Policy</a></h1>
<p>To understand the Kiosk we first need to go through the Transfer Policy.
<code>transfer_policy</code> is a library located in the Sui Framework; it allows creating
a non-discardable message - called <code>TransferRequest</code> - and the destination for
this message - <code>TransferPolicy</code>.</p>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>Imagine a tax system implementation: multiple merchants process payments and
buyers need to pay &quot;<a href="https://en.wikipedia.org/wiki/Value-added_tax">VAT</a>&quot;. The
tax is calculated based on the price of the purchased item, and different
categories of items have different tax rates.</p>
<blockquote>
<p>In most of the countries, the VAT is first collected by the merchant. The
merchant must keep track of the tax paid for each item and pay the collected
taxes to the tax authority in the end of the period.</p>
</blockquote>
<p>To create a system like this without extra overhead on the merchants' side (the
buyer pays the tax directly) we could issue a &quot;receipt&quot; for each purchase which
would contain the information about the item type and the price paid. The buyer
would then need to pay the VAT directly to the tax authority based on the
receipt.</p>
<p>Move language has a primitive which allows creating a non-discardable message
called &quot;<a href="https://examples.sui.io/patterns/hot-potato.html">Hot Potato</a>&quot;. Once
created, the Hot Potato can only be consumed by a specific module (or object),
and if it is not consumed, the transaction will fail.</p>
<p>Applied to this scenario, the &quot;receipt&quot; would be a Hot Potato, forcing the buyer
to do something with it - pay the tax - before the transaction can be finalized.</p>
<h2><a class="header" href="#transfer-request" id="transfer-request">Transfer Request</a></h2>
<p>The <code>TransferRequest</code> struct and the matching <code>TransferPolicy</code> object address
this problem. If a merchant creates a <code>TransferRequest</code> upon each purchase, and
the <code>TransferPolicy</code> is configured to enforce the tax policy, the buyer will not
be able to finalize the purchase the item until the tax is paid.</p>
<p>This is a strong guarantee, because the <code>TransferRequest</code> is a non-discardable
struct - &quot;Hot Potato&quot; - and unless it finds &quot;its home&quot;, the transaction won't
succeed. The <code>TransferPolicy</code> is the &quot;home&quot; for the <code>TransferRequest</code> and it
can be configured by the authority to require certain conditions to be met for
the <code>TransferRequest</code> to be accepted.</p>
<p>Because the system is designed for commerce, the <code>TransferRequest</code> has the most
commonly used fields, all of which are set at creation and can't be changed,
such as:</p>
<ul>
<li><code>paid</code> (the amount of SUI paid for the item)</li>
<li><code>item</code> (the ID of the item being transferred)</li>
<li><code>from</code> (the ID of the source the item is being sold from)</li>
</ul>
<p>Additionally, thanks to the Move's type system, the <code>TransferRequest</code> is issued
per <em>type</em>. This means that the <code>TransferRequest</code> for a &quot;Phone&quot; is different
from the <code>TransferRequest</code> for a &quot;Car&quot;. This allows to enforce different rules
for different types of items.</p>
<h2><a class="header" href="#example-merchant" id="example-merchant">Example: Merchant</a></h2>
<p>A module implementing the merchant logic for the &quot;Phone&quot; type could look like
this:</p>
<pre><code class="language-Move">/// An example of a module on Sui which sells &quot;Phones&quot;.
module commerce::merchant {
    use sui::transfer_policy::{Self, TransferRequest};
    use tax::vat::VAT;

    /// A single &quot;Phone&quot; - a Sui Object.
    struct Phone has key, store { /* ... */ }

    /// A price of a single &quot;Phone&quot;.
    const PHONE_PRICE: u64 = 10_000_000_000;

    /// Some merchant ID (usually represented by a Sui Object)
    const MERCHANT_ID: address = 0xBEEF;

    /// The merchant is selling phones, the buyer only pays to the merchant the
    /// price of the phone, and the tax is paid separately and directly to the
    /// tax authority. `VAT` type is imported and can only be resolved by the
    /// authority defining this type.
    public fun buy_phone(/* pass a coin */): (Phone, TransferRequest&lt;VAT&gt;) {

        let phone = Phone { /* ... */ };

        // Generate new `TransferRequest` for the `VAT` type, specify the ID
        // of the `Phone` object, the price of the `Phone` and the ID of the
        // merchant.
        let request = transfer_policy::new_request&lt;VAT&gt;(
            object::id(&amp;phone),
            PHONE_PRICE,
            object::id_from_address(MERCHANT_ID),
        );

        (phone, request)
    }
}
</code></pre>
<h2><a class="header" href="#transfer-policy-1" id="transfer-policy-1">Transfer Policy</a></h2>
<p>A <code>TransferRequest</code> can only be matched in a <code>TransferPolicy</code> object. The match
happens based on the type of the <code>TransferRequest</code> and the <code>TransferPolicy</code>. If
the <code>TransferRequest</code> is for the &quot;Phone&quot; type, it can only be matched by the
<code>TransferPolicy</code> for the &quot;Phone&quot; type.</p>
<blockquote>
<p>In the example above the <code>TransferRequest</code> is for the &quot;VAT&quot; type, so it can
only be matched by the <code>TransferPolicy</code> for the &quot;VAT&quot; type.</p>
</blockquote>
<p><code>TransferPolicy&lt;T&gt;</code> is a Sui Object which can be created for any type by the
<a href="https://examples.sui.io/basics/publisher.html">Publisher</a> of this type.</p>
<pre><code class="language-Move">/// An example of a TransferPolicy setup. Better be done via PTBs and not as a
/// published module. The code below is for illustration purposes only.
module tax::vat {
    use sui::tx_context::{sender, TxContext};
    use sui::transfer_policy::{Self, TransferPolicy};

    /// The authority defines the `VAT` type. It is never initialized and only
    /// used to create and resolve `TransferRequest`s.
    struct VAT has drop {}

    /// The publisher creates and shares a `TransferPolicy` for the `VAT` type.
    public fun create_policy(pub: &amp;Publisher, ctx: &amp;mut TxContext) {
        let (policy, policy_cap) = transfer_policy::new_policy&lt;VAT&gt;(pub, ctx);

        sui::transfer::public_share_object(policy);
        sui::transfer::public_transfer(policy_cap, sender(ctx));
    }

    /// Can be called directly in the `TransferPolicy` module; does not need a
    /// custom implementation. This code is for illustration purposes only.
    public fun confirm_request(
        policy: &amp;TransferPolicy&lt;VAT&gt;, request: TransferRequest&lt;VAT&gt;
    ) {
        transfer_policy::confirm_request&lt;VAT&gt;(policy, request);
    }

    /// Using the OTW (VAT), create the Publisher object and transfer it to the
    /// transaction sender.
    fun init(otw: VAT, ctx: &amp;mut TxContext) {
        sui::package::claim_and_keep(otw, ctx);
    }
}
</code></pre>
<h1><a class="header" href="#rules" id="rules">Rules</a></h1>
<p>The <code>TransferPolicy</code> does not require any action from the user by default; it
confirms <code>TransferRequest</code>s and therefore unblocks a transaction. However, if we
were to implement the <code>VAT</code> example further and allow the <code>VAT</code> to collect fees
for every &quot;merchant transaction&quot; we need to introduce &quot;Rules&quot;.</p>
<h2><a class="header" href="#receipts-in-transferrequest" id="receipts-in-transferrequest">&quot;Receipts&quot; in TransferRequest</a></h2>
<p>TransferRequest features the <code>receipts</code> field which is a VecSet of <code>TypeName</code>.
When the request is &quot;confirmed&quot; via the <code>confirm_request</code> call, the receipts are
compared against the <code>TransferPolicy.rules</code>, and if &quot;receipts&quot; don't match the
&quot;rules&quot;, the request can not be confirmed, and the transaction aborts.</p>
<p>In the default scenario, the rules are empty and receipts are too, so the
matching is trivial and the request is confirmed.</p>
<pre><code class="language-Move">module sui::transfer_policy {
    // ... skipped ...

    struct TransferRequest&lt;phantom T&gt; {
        // ... other fields omitted ...

        /// Collected Receipts. Used to verify that all of the rules
        /// were followed and `TransferRequest` can be confirmed.
        receipts: VecSet&lt;TypeName&gt;
    }

    // ... skipped ...

    struct TransferPolicy&lt;phantom T&gt; has key, store {
        // ... other fields omitted ...

        /// Set of types of attached rules - used to verify `receipts` when
        /// a `TransferRequest` is received in `confirm_request` function.
        ///
        /// Additionally provides a way to look up currently attached Rules.
        rules: VecSet&lt;TypeName&gt;
    }

    // ...
}
</code></pre>
<h2><a class="header" href="#rules-and-receipts" id="rules-and-receipts">Rules and Receipts</a></h2>
<p>A Rule is a way to request an additional action from the user before the request
can be confirmed. For example, if we want to implement a &quot;VAT&quot; module that would
collect fees for every &quot;merchant transaction&quot;, we need to introduce a Rule that
would allow the VAT to collect fees. The way for us to know that the VAT is paid
is to add a &quot;receipt&quot; to the TransferRequest.</p>
<blockquote>
<p>A Rule added to the TransferPolicy requires a matching Receipt in the
TransferRequest. The match is performed based on the Rule type.</p>
</blockquote>
<h2><a class="header" href="#rule-implementation" id="rule-implementation">Rule Implementation</a></h2>
<p>A rule is a module that implements the &quot;Rule&quot; functionality in the
<code>transfer_policy</code> module - it needs to provide 3 main components:</p>
<ol>
<li>A <code>Rule</code> Witness type which uniquely identifies the Rule</li>
<li>A <code>Config</code> type which is stored in the <code>TransferPolicy</code> and is used to
configure the Rule (eg a fee amount)</li>
<li>An <code>add</code> function which adds the Rule to the <code>TransferPolicy</code> - must be
performed by the <code>TransferPolicyCap</code> holder</li>
<li>An actionable function which adds the receipt into the <code>TransferRequest</code> and
potentially adds to the <code>TransferPolicy</code> balance if the functionality
involves some monetary transaction.</li>
</ol>
<!-- transfer_policy::add_rule(W, TransferPolicy, TransferPolicyCap, Config) /// adds a rule to the policy; rule is protected by the rule module’s witness; config must have drop
• transfer_policy::add_to_balance(W, TransferPolicy, Coin) /// add some SUI to the balance of the TransferPolicy (eg on royalty payment)
• transfer_policy::add_receipt(W, TransferRequest) /// adds a receipt that the rule requirements are fulfilled; all of the receipts must be collected before confirmation
• transfer_policy::remove_rule<W>(TransferPolicy, TransferPolicyCap); /// remove the rule from the policy - applied instantly -->
<h1><a class="header" href="#guide-writing-rules" id="guide-writing-rules">Guide: Writing Rules</a></h1>
<!-- Guide migrated from the sui repository -->
<p>When an item is purchased in a Kiosk, a <code>TransferRequest</code> hot-potato is created, and the only way to resolve it and unblock the transaction is to confirm the request in the matching TransferPolicy. This guide explains how the TransferPolicy works and how new rules can be implemented and added into a policy.</p>
<h2><a class="header" href="#basics" id="basics">Basics</a></h2>
<p>An item of a type T can only be traded in Kiosks if the TransferPolicy for T exists and available to the buyer. This requirement is based on a simple fact that the TransferRequest issued on purchase must be resolved in a matching TransferPolicy and if there isn't one or buyer can't access it, the transaction will fail.</p>
<p>This system was designed to give maximum freedom and flexibility for creators: by taking the transfer policy logic out of the trading primitive we make sure that the policies can be set only by creators, and as long as the trading primitive is used, enforcements are under their control. Effectively creators became closer to the trading ecosystem and got an important and solid role in the process.</p>
<h2><a class="header" href="#architecture" id="architecture">Architecture</a></h2>
<p>By default, a single TransferPolicy does not enforce anything - if a buyer attempts to confirm their TransferRequest, it will go through. However, the system allows setting so-called &quot;Rules&quot;. Their logic is simple: someone can publish a new rule module, for example &quot;fixed fee&quot;, and let it be &quot;added&quot; or &quot;set&quot; for the TransferPolicy. Once the Rule is added, TransferRequest needs to collect a TransferReceipt marking that the requiement specified in the Rule was completed.</p>
<p>[TODO]</p>
<ul>
<li>Once a Rule is added to the TransferPolicy, every TransferRequest going to the policy must have a matching Receipt</li>
</ul>
<h2><a class="header" href="#rule-structure-dummy" id="rule-structure-dummy">Rule structure: Dummy</a></h2>
<p>Every rule would follow the same structure and implement required types:</p>
<ol>
<li>RuleWitness struct</li>
<li>Config struct stored in the TransferPolicy</li>
<li>&quot;set&quot; function which adds the Rule to the TP</li>
<li>an action function which adds a Receipt to the TransferRequest</li>
</ol>
<blockquote>
<p>Important: there's no need to implement &quot;unset&quot; - any rule can be removed at any time as defined
in the TransferPolicy module and guaranteed by the set of constraints on the rule Config (store + drop)</p>
</blockquote>
<pre><code class="language-move">module examples::dummy_rule {
    use sui::coin::Coin;
    use sui::sui::SUI;
    use sui::transfer_policy::{
        Self as policy,
        TransferPolicy,
        TransferPolicyCap,
        TransferRequest
    };

    /// The Rule Witness; has no fields and is used as a
    /// static authorization method for the rule.
    struct Rule has drop {}

    /// Configuration struct with any fields (as long as it
    /// has `drop`). Managed by the Rule module.
    struct Config has store, drop {}

    /// Function that adds a Rule to the `TransferPolicy`.
    /// Requires `TransferPolicyCap` to make sure the rules are
    /// added only by the publisher of T.
    public fun add&lt;T&gt;(
        policy: &amp;mut TransferPolicy&lt;T&gt;,
        cap: &amp;TransferPolicyCap&lt;T&gt;
    ) {
        policy::add_rule(Rule {}, policy, cap, Config {})
    }

    /// Action function - perform a certain action (any, really)
    /// and pass in the `TransferRequest` so it gets the Receipt.
    /// Receipt is a Rule Witness, so there's no way to create
    /// it anywhere else but in this module.
    ///
    /// This example also illustrates that Rules can add Coin&lt;SUI&gt;
    /// to the balance of the TransferPolicy allowing creators to
    /// collect fees.
    public fun pay&lt;T&gt;(
        policy: &amp;mut TransferPolicy&lt;T&gt;,
        request: &amp;mut TransferRequest&lt;T&gt;,
        payment: Coin&lt;SUI&gt;
    ) {
        policy::add_to_balance(Rule {}, policy, payment);
        policy::add_receipt(Rule {}, request);
    }
}
</code></pre>
<p>This module contains no configuration and requires a <code>Coin&lt;SUI&gt;</code> of any value (even &quot;0&quot;), so it's
easy to imagine that every buyer would create a zero Coin and pass it to get the Receipt. The only
thing this Rule module is good for is illustration and a skeleton. Goes without saying but <strong>this
code should never be used in production</strong>.</p>
<h2><a class="header" href="#reading-the-request-royalty" id="reading-the-request-royalty">Reading the Request: Royalty</a></h2>
<p>To implement a percentage-based fee (a very common scenario - royalty fee), a Rule module needs to
know the price for which an item was purchased. And the TransferRequest contains some information
which can be used in this and other scenarios:</p>
<ol>
<li>Item ID</li>
<li>Amount paid (SUI)</li>
<li>From ID - the object which was used for selling (eg Kiosk)</li>
</ol>
<blockquote>
<p>To provide access to these fields, the <code>sui::transfer_policy</code> module has a set of getter functions
which are available to anyone: &quot;paid()&quot;, &quot;item()&quot; and &quot;from()&quot;</p>
</blockquote>
<pre><code class="language-move">module examples::royalty_rule {
    // skipping dependencies
    const MAX_BP: u16 = 10_000;

    struct Rule has drop {}

    /// In this implementation Rule has a configuration - `amount_bp`
    /// which is the percentage of the `paid` in basis points.
    struct Config has store, drop { amount_bp: u16 }

    /// When a Rule is added, configuration details are specified
    public fun add&lt;T&gt;(
        policy: &amp;mut TransferPolicy&lt;T&gt;,
        cap: &amp;TransferPolicyCap&lt;T&gt;,
        amount_bp: u16
    ) {
        assert!(amount_bp &lt;= MAX_BP, 0);
        policy::add_rule(Rule {}, policy, cap, Config { amount_bp })
    }

    /// To get the Receipt, the buyer must call this function and pay
    /// the required amount; the amount is calculated dynamically and
    /// it is more convenient to use a mutable reference
    public fun pay&lt;T&gt;(
        policy: &amp;mut TransferPolicy&lt;T&gt;,
        request: &amp;mut TransferRequest&lt;T&gt;,
        payment: &amp;mut Coin&lt;SUI&gt;,
        ctx: &amp;mut TxContext
    ) {
        // using the getter to read the paid amount
        let paid = policy::paid(request);
        let config: &amp;Config = policy::get_rule(Rule {}, policy);
        let amount = (((paid as u128) * (config.amount_bp as u128) / MAX_BP) as u64);
        assert!(coin::value(payment) &gt;= amount, EInsufficientAmount);

        let fee = coin::split(payment, amount, ctx);
        policy::add_to_balance(Rule {}, policy, fee);
        policy::add_receipt(Rule {}, request)
    }
}
</code></pre>
<h2><a class="header" href="#time-is-also-money" id="time-is-also-money">Time is also Money</a></h2>
<p>Rules don't need to be only for payments and fees. Some might allow trading before or after a
certain time. Since Rules are not standardized and can use anything, developers can encode logic
around using any objects.</p>
<pre><code class="language-move">module examples::time_rule {
    // skipping some dependencies
    use sui::clock::{Self, Clock};

    struct Rule has drop {}
    struct Config has store, drop { start_time: u64 }

    /// Start time is yet to come
    const ETooSoon: u64 = 0;

    /// Add a Rule that enables purchases after a certain time
    public fun add&lt;T&gt;(/* skip default fields */, start_time: u64) {
        policy::add_rule(Rule {}, policy, cap, Config { start_time })
    }

    /// Pass in the Clock and prove that current time value is higher
    /// than the `start_time`
    public fun confirm_time&lt;T&gt;(
        policy: &amp;TransferPolicy&lt;T&gt;,
        request: &amp;mut TransferRequest&lt;T&gt;,
        clock: &amp;Clock
    ) {
        let config: &amp;Config = policy::get_rule(Rule {}, policy)
        assert!(clock::timestamp_ms(clock) &gt;= config.start_time, ETooSoon);
        policy::add_receipt(Rule {}, request)
    }
}
</code></pre>
<h2><a class="header" href="#generalizing-approach-witness-policy" id="generalizing-approach-witness-policy">Generalizing approach: Witness policy</a></h2>
<p>Sui Move has two main ways for authorizing an action: static - by using the Witness pattern, and
dynamic - via the Capability pattern. With a small addition of type parameters to the Rule, it is
possible to create a <em>generic Rule</em> which will not only vary by configuration but also by the type
of the Rule.</p>
<pre><code class="language-move">module examples::witness_rule {
    // skipping dependencies

    /// Rule is either not set or the Witness does not match the expectation
    const ERuleNotSet: u64 = 0;

    /// This Rule requires a witness of type W, see the implementation
    struct Rule&lt;phantom W&gt; has drop {}
    struct Config has store, drop {}

    /// No special arguments are required to set this Rule, but the
    /// publisher now needs to specify a Witness type
    public fun add&lt;T, W&gt;(/* .... */) {
        policy::add_rule(Rule&lt;W&gt; {}, policy, cap, Config {})
    }

    /// To confirm the action, buyer needs to pass in a witness
    /// which should be acquired either by calling some function or
    /// integrated into a more specific hook of a marketplace /
    /// trading module
    public fun confirm&lt;T, W&gt;(
        _: W,
        policy: &amp;TransferPolicy&lt;T&gt;,
        request: &amp;mut TransferRequest&lt;T&gt;
    ) {
        assert!(policy::has_rule&lt;T, Rule&lt;W&gt;&gt;(policy), ERuleNotSet);
        policy::add_receipt(Rule&lt;W&gt; {}, request)
    }
}
</code></pre>
<p>The &quot;witness_rule&quot; is very generic and can be used to require a custom Witness depending on the
settings. It is a simple and yet a powerful way to link a custom marketplace / trading logic to the
TransferPolicy. With a slight modification, the rule can be turned into a generic Capability
requirement (basically any object, even a TransferPolicy for a different type or a TransferRequest -
no limit to what could be done).</p>
<pre><code class="language-move">module examples::capability_rule {
    // skipping dependencies

    /// Changing the type parameter name for better readability
    struct Rule&lt;phantom Cap&gt; has drop {}
    struct Config {}

    /// Absolutely identical to the witness setting
    public fun add&lt;T, Cap&gt;(/* ... *) {
        policy::add_rule(Rule&lt;Cap&gt; {}, policy, cap, Config {})
    }

    /// Almost the same with the Witness requirement, only now we
    /// require a reference to the type.
    public fun confirm&lt;T, Cap&gt;(
        cap: &amp;Cap,
        /* ... */
    ) {
        assert!(policy::has_rule&lt;T, Rule&lt;Cap&gt;&gt;(policy), ERuleNotSet);
        policy::add_receipt(Rule&lt;Cap&gt; {}, request)
    }
}
</code></pre>
<h1><a class="header" href="#multiple-transfer-policies" id="multiple-transfer-policies">Multiple Transfer Policies</a></h1>
<p>While most of the scenarios imply having a single <code>TransferPolicy</code> for a type, it is possible to create multiple policies for different purposes. For example, a default policy for &quot;VAT&quot; would require everyone to use it. However, if a person is leaving the country, they can get their VAT refunded; is it possible to resolve? The answer is yes, and it is possible to do it without changing the default policy.</p>
<p>To do so, a second <code>TransferPolicy</code> for the same type can be issued and usually wrapped into a custom object to implement the logic. For example, a &quot;TaxFreePolicy&quot; object can be created and used to ignore - not pay - VAT. The object will store another <code>TransferPolicy</code> which can be accessed only if the buyer shows a valid &quot;Passport&quot; object. The inner policy may contain no rules, therefore not requiring any fees to be paid.</p>
<h1><a class="header" href="#kiosk" id="kiosk">Kiosk</a></h1>
<p>Kiosk is the </p>
<h1><a class="header" href="#open-a-kiosk" id="open-a-kiosk">Open a Kiosk</a></h1>
<p>To use a Kiosk, the user needs to create one and have the <code>KioskOwnerCap</code> that matches the <code>Kiosk</code> object. Once created, all of the features of the Kiosk are available to the owner.</p>
<h2><a class="header" href="#default-setup" id="default-setup">Default setup</a></h2>
<p>Anyone can create a new Kiosk in a single transaction by calling the <code>kiosk::default</code> function. It will create and share a Kiosk and transfer the <code>KioskOwnerCap</code> to the transaction sender.</p>
<p><strong>Example Kiosk SDK</strong></p>
<pre><code class="language-js">import { createKioskAndShare } from '@mysten/kiosk';

let txb = new TransactionBuilder();
let kioskOwnerCap = createKioskAndShare(txb);

txb.transferObjects([ kioskOwnerCap ], tx.pure(sender, 'address'));
</code></pre>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">let txb = new TransactionBuilder();
txb.moveCall({
    target: '0x2::kiosk::default'
});
</code></pre>
<p><strong>Example CLI</strong></p>
<pre><code class="language-bash">sui client call \
    --package 0x2 \
    --module kiosk \
    --function default \
    --gas-budget 1000000000
</code></pre>
<h2><a class="header" href="#advanced-usage" id="advanced-usage">Advanced usage</a></h2>
<p>For more advanced use cases, when you want to choose the storage model or perform an action right away, you can use a PTB-friendly function <code>kiosk::new</code>.</p>
<blockquote>
<p>Kiosk is intended to be <strong>shared</strong> and choosing a different storage model (eg &quot;owned&quot;) would lead to Kiosk not being fully functional and not available for other users. Make sure you know what you're doing.</p>
</blockquote>
<p><strong>Example Kiosk SDK</strong></p>
<pre><code class="language-js">import { createKiosk } from '@mysten/kiosk';

let txb = new TransactionBuilder();
let [kiosk, kioskOwnerCap] = createKiosk(txb);

txb.transferObjects([ kioskOwnerCap ], tx.pure(sender, 'address'));
txb.moveCall({
    target: '0x2::transfer::public_share_object',
    arguments: [ kiosk ],
    typeArguments: '0x2::kiosk::Kiosk'
})
</code></pre>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">let txb = new TransactionBuilder();
let [kiosk, kioskOwnerCap] = txb.moveCall({
    target: '0x2::kiosk::new'
});

txb.transferObjects([ kioskOwnerCap ], tx.pure(sender, 'address'));
txb.moveCall({
    target: '0x2::transfer::public_share_object',
    arguments: [ kiosk ],
    typeArguments: '0x2::kiosk::Kiosk'
})
</code></pre>
<h1><a class="header" href="#place-and-take" id="place-and-take">Place and Take</a></h1>
<p>Kiosk owner can <em>place</em> any items into their Kiosk, <em>placed</em> items can be <em>taken</em> by the owner if they're not <a href="kiosk/./list-and-purchase.html"><em>listed</em></a>.</p>
<p>There's no limitations to which items can be placed into the Kiosk, however, it does not guarantee that they will be <em>tradable</em> - that depends on whether there's a <a href="kiosk/../transfer-policy/README.html">TransferPolicy</a> for the type.</p>
<h2><a class="header" href="#calling-kioskplace" id="calling-kioskplace">Calling <code>kiosk::place</code></a></h2>
<p>To place an item to the Kiosk, the owner needs to call the <code>sui::kiosk::place</code> function on the Kiosk object and pass the KioskOwnerCap and the Item as arguments.</p>
<blockquote>
<p><code>ITEM_TYPE</code> in the examples below is the full type of the item.</p>
</blockquote>
<p><strong>Example Kiosk SDK</strong></p>
<pre><code class="language-js">import { place } from '@mysten/kiosk';

let tx = new TransactionBuilder();

let itemArg = tx.object('&lt;ID&gt;');
let kioskArg = tx.object('&lt;ID&gt;');
let kioskOwnerCapArg = tx.object('&lt;ID&gt;');

place(tx, '&lt;ITEM_TYPE&gt;', kioskArg, kioskOwnerCapArg, item);
</code></pre>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">let tx = new TransactionBuilder();

let itemArg = tx.object('&lt;ID&gt;');
let kioskArg = tx.object('&lt;ID&gt;');
let kioskOwnerCapArg = tx.object('&lt;ID&gt;');

tx.moveCall({
    target: '0x2::kiosk::place',
    arguments: [ kioskArg, kioskOwnerCapArg, itemArg ],
    typeArguments: [ '&lt;ITEM_TYPE&gt;' ]
})
</code></pre>
<h2><a class="header" href="#calling-kiosktake" id="calling-kiosktake">Calling <code>kiosk::take</code></a></h2>
<p>To take an item from the Kiosk, the owner needs to call the <code>sui::kiosk::take</code> function on the Kiosk object and pass the KioskOwnerCap and ID of the item as arguments.</p>
<blockquote>
<p><code>ITEM_TYPE</code> in the examples below is the full type of the item.</p>
</blockquote>
<p><strong>Example Kiosk SDK</strong></p>
<pre><code class="language-js">import { take } from '@mysten/kiosk';

let tx = new TransactionBuilder();

let itemId = tx.pure('&lt;ITEM_ID&gt;', 'address');
let kioskArg = tx.object('&lt;ID&gt;');
let kioskOwnerCapArg = tx.object('&lt;ID&gt;');

let item = take('&lt;ITEM_TYPE&gt;', kioskArg, kioskOwnerCapArg, itemId);

tx.transferObjects([ item ], tx.pure(sender, 'address'));
</code></pre>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">let tx = new TransactionBuilder();

let itemId = tx.pure('&lt;ITEM_ID&gt;', 'address');
let kioskArg = tx.object('&lt;ID&gt;');
let kioskOwnerCapArg = tx.object('&lt;ID&gt;');

let item = tx.moveCall({
    target: '0x2::kiosk::take',
    arguments: [ kioskArg, kioskOwnerCapArg, itemId ],
    typeArguments: [ '&lt;ITEM_TYPE&gt;' ]
});
</code></pre>
<h1><a class="header" href="#locking" id="locking">Locking</a></h1>
<p>Some policies may require items to never leave Kiosk (eg in a strong royalty enforcement scenario), and for that Kiosk has a locking mechanism.</p>
<blockquote>
<p><em>Locking</em> is similar to <a href="kiosk/./place-and-take.html#calling-kioskplace"><em>placing</em></a> with an exception, that a locked item can not be <a href="kiosk/./place-and-take.html#calling-kiosktake"><em>taken</em></a> out of the Kiosk.</p>
</blockquote>
<p>An item can be <em>locked</em> in a Kiosk by calling the <code>sui::kiosk::lock</code> function. To make sure that the item can be eventually unlocked, the call requires a <a href="kiosk/../transfer-policy/README.html">TransferPolicy</a> to exist.</p>
<h3><a class="header" href="#calling-kiosklock" id="calling-kiosklock">Calling <code>kiosk::lock</code></a></h3>
<p>Similar to <a href="kiosk/./place-and-take.html"><em>place</em></a>, <em>lock</em> call requires the KioskOwnerCap and the Item as arguments, but also requires the TransferPolicy to be shown.</p>
<blockquote>
<p><code>ITEM_TYPE</code> in the examples below is the full type of the item.</p>
</blockquote>
<p><strong>Example Kiosk SDK</strong></p>
<pre><code class="language-js">import { lock } from '@mysten/kiosk';

const tx = new TransactionBuilder();

let kioskArg = tx.object('&lt;ID&gt;');
let kioskOwnerCapArg = tx.object('&lt;ID&gt;');
let itemArg = tx.object('&lt;ID&gt;');
let transferPolicyArg = tx.object('&lt;ID&gt;');

lock(tx, '&lt;ITEM_TYPE&gt;', kioskArg, kioskOwnerCapArg, transferPolicyArg, itemArg);
</code></pre>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">const tx = new TransactionBuilder();

let kioskArg = tx.object('&lt;ID&gt;');
let kioskOwnerCapArg = tx.object('&lt;ID&gt;');
let itemArg = tx.object('&lt;ID&gt;');
let transferPolicyArg = tx.object('&lt;ID&gt;');

tx.moveCall({
    target: '0x2::kiosk::lock',
    arguments: [ kioskArg, kioskOwnerCapArg, transferPolicyArg, itemArg ],
    typeArguments: [ '&lt;ITEM_TYPE&gt;' ]
});
</code></pre>
<h1><a class="header" href="#list-and-purchase" id="list-and-purchase">List and Purchase</a></h1>
<h1><a class="header" href="#borrowing" id="borrowing">Borrowing</a></h1>
<h1><a class="header" href="#withdrawing-profits" id="withdrawing-profits">Withdrawing Profits</a></h1>
<h1><a class="header" href="#purchasecap-tricks" id="purchasecap-tricks">PurchaseCap tricks</a></h1>
<h1><a class="header" href="#extensions" id="extensions">Extensions</a></h1>
<h1><a class="header" href="#kiosk-extensions" id="kiosk-extensions">Kiosk Extensions</a></h1>
<p>Extensions are a way to extend the functionality of Kiosk while keeping the core functionality
intact. They are a way to add new features to the Kiosk without having to modify the core code or
move the assets elsewhere.</p>
<h2><a class="header" href="#types-of-extensions" id="types-of-extensions">Types of Extensions</a></h2>
<p>There are two types of extensions:</p>
<h3><a class="header" href="#simple-extensions" id="simple-extensions">Simple Extensions</a></h3>
<p>Ones that do not require Extensions API to function. They usually serve the purpose of adding custom
metadata to the Kiosk or wrapping / working with exising objects such as <code>Kiosk</code> or <code>KioskOwnerCap</code>.
An example of an extension that does not require the API is the
<a href="kiosk-extensions/../mysten_kiosk/extensions/personal_kiosk.html">Personal Kiosk</a> extension.</p>
<h3><a class="header" href="#permissioned-extensions" id="permissioned-extensions">Permissioned Extensions</a></h3>
<p>&quot;Permissioned&quot; extensions use the Extensions API to perform actions in the Kiosk. They usually imply
interaction with a third party and provide guarantees for the storage access (preventing the
malicious actions from the seller).</p>
<h1><a class="header" href="#simple-extensions-1" id="simple-extensions-1">Simple Extensions</a></h1>
<p>Some extensions may be implemented without the &quot;more advanced&quot; Kiosk Extensions API. To understand
the approaches to building extensions of this kind, let's look at the tools that are available to
the extension developer.</p>
<h2><a class="header" href="#uid-access-via-the-uid_mut" id="uid-access-via-the-uid_mut">UID access via the <code>uid_mut</code></a></h2>
<p>Kiosk, like any object on Sui, has an <code>id: UID</code> field, which allows this object to not just be
uniquely identified but also carry custom dynamic fields and dynamic object fields. The Kiosk itself
is built around dynamic fields and features like <a href="kiosk-extensions/../kiosk/place-and-take.html">place</a> and
<a href="kiosk-extensions/../kiosk/list-and-purchase.html">list</a> are built around dynamic object fields.</p>
<h3><a class="header" href="#the-uid_mut_as_owner-function" id="the-uid_mut_as_owner-function">The <code>uid_mut_as_owner</code> function</a></h3>
<p>Kiosk can carry additional dynamic fields and dynamic object fields. The <code>uid_mut_as_owner</code> function
allows the Kiosk Owner to mutably access the <code>UID</code> of the <code>Kiosk</code> object and use it to add or remove
custom fields.</p>
<blockquote>
<p>Function signature:</p>
<pre><code class="language-Move">kiosk::uid_mut_as_owner(self: &amp;mut Kiosk, cap: &amp;KioskOwnerCap): &amp;mut UID
</code></pre>
</blockquote>
<h3><a class="header" href="#the-public-uid-getter" id="the-public-uid-getter">The public <code>uid</code> getter</a></h3>
<p>Anyone can read the <code>uid</code> of the Kiosk. This allows third party modules read the fields of the Kiosk
if they're allowed to do so (TODO: Custom Dynamic Field Keys). Therefore enabling the &quot;Object
Capability&quot; and other patterns.</p>
<!-- ## Wrapping the KioskOwnerCap

KioskOwnerCap is a capability that makes the bearer the owner of the Kiosk. It allows the owner to -->
<h1><a class="header" href="#extensions-api" id="extensions-api">Extensions API</a></h1>
<p>Just having access to the <code>uid</code> is often not enough to build an extension due to the security limitations. Only Kiosk Owner has full access to the <code>uid</code>, which means that an extension involving a third party would require the Kiosk Owner to be involved in every step of the process.</p>
<p>Not only the access to storage is limited and constrained but also the permissions of the extension. In the default setup, no party can <code>place</code> or <code>lock</code> items in a Kiosk without its Owner's consent. So some cases such as &quot;collection bidding&quot; (I offer X SUI for any item in this collection) will require the Kiosk Owner to approve the bid.</p>
<h3><a class="header" href="#kiosk_extension-module" id="kiosk_extension-module"><code>kiosk_extension</code> module</a></h3>
<p>To address these concerns and provide more guarantees over the storage access, we created the <code>kiosk_extension</code> module. It provides a set of functions which enable the extension developer to perform certain actions in the Kiosk without the Kiosk Owner's involvement and have a guarantee that the storage of the extension is not tampered with.</p>
<pre><code class="language-Move">module example::my_extension {
    use sui::kiosk_extension;

    // ...
}
</code></pre>
<h3><a class="header" href="#extension-lifecycle" id="extension-lifecycle">Extension Lifecycle</a></h3>
<ol>
<li>An extension can only be installed by an explicit call in the extension module.</li>
<li>Kiosk Owner can revoke permissions of an extension at any time by calling the <code>disable</code> function.</li>
<li>A disabled extension can be re-enabled at any time by the Kiosk Owner by calling the <code>enable</code> function.</li>
<li>Extension can be removed only in if the Extension Storage is empty, i.e. all items are removed.</li>
</ol>
<h1><a class="header" href="#adding-an-extension" id="adding-an-extension">Adding an Extension</a></h1>
<p>For the extension to function, it first needs to be installed by the Kiosk owner. To achieve that, an extension needs to implement the <code>add</code> function which will be called by the Kiosk owner and will request <a href="kiosk-extensions/extensions-api/./extension-permissions.html">all necessary permissions</a>.</p>
<h2><a class="header" href="#implementing-add-function" id="implementing-add-function">Implementing <code>add</code> function</a></h2>
<p>The signature of the <code>kiosk_extension::add</code> function requires the extension witness making it impossible to install an extension without an explicit implementation provided by the extension. The following example shows how to implement the <code>add</code> function for an extension that requires the <code>place</code> permission:</p>
<pre><code class="language-Move">module examples::letterbox_ext {
    // ... dependencies

    /// The expected set of permissions for extension. It requires `place`.
    const PERMISSIONS: u128 = 1;

    /// The Witness struct used to identify and authorize the extension.
    struct Extension has drop {}

    /// Install the Mallbox extension into the Kiosk.
    public fun add(kiosk: &amp;mut Kiosk, cap: &amp;KioskOwnerCap, ctx: &amp;mut TxContext) {
        kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)
    }
}
</code></pre>
<h1><a class="header" href="#extension-permissions" id="extension-permissions">Extension Permissions</a></h1>
<p>Extensions can request permissions from the Kiosk Owner on installation. Permissions follow the all or nothing principle. If the Kiosk Owner adds an extension it gets all of the requested permissions; if the Kiosk Owner then <em>disables</em> an extension, all of its permissions are revoked.</p>
<h2><a class="header" href="#structure" id="structure">Structure</a></h2>
<p>Permissions are represented as a <code>u128</code> integer storing a <a href="https://en.wikipedia.org/wiki/Bit_array">bitmap</a>. Each of the bits corresponds to a permission, the first bit is the least significant bit. The following table lists all permissions and their corresponding bit:</p>
<table><thead><tr><th>Bit</th><th>Decimal</th><th>Permission</th></tr></thead><tbody>
<tr><td><code>0000</code></td><td><code>0</code></td><td>No permissions</td></tr>
<tr><td><code>0001</code></td><td><code>1</code></td><td>Extension can place</td></tr>
<tr><td><code>0010</code></td><td><code>2</code></td><td>Extension can place and lock</td></tr>
<tr><td><code>0011</code></td><td><code>3</code></td><td>Extension can place and lock</td></tr>
</tbody></table>
<p>Currently, Kiosk has only 2 permissions: <code>place</code> (1st bit) and <code>lock</code> and <code>place</code> (2nd bit). The rest of the bits are reserved for future use.</p>
<h2><a class="header" href="#using-permissions-in-the-add-function" id="using-permissions-in-the-add-function">Using permissions in the <code>add</code> function</a></h2>
<p>It's a good practice to define a constant containing permissions of the extension:</p>
<pre><code class="language-Move">module examples::letterbox_ext {
    // ... dependencies

    /// The expected set of permissions for extension. It requires `place`.
    const PERMISSIONS: u128 = 1;

    /// The Witness struct used to identify and authorize the extension.
    struct Extension has drop {}

    /// Install the Mallbox extension into the Kiosk and request `place` permission.
    public fun add(kiosk: &amp;mut Kiosk, cap: &amp;KioskOwnerCap, ctx: &amp;mut TxContext) {
        kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)
    }
}
</code></pre>
<h2><a class="header" href="#accessing-protected-functions" id="accessing-protected-functions">Accessing protected functions</a></h2>
<p>If Extension requested permissions and was added and if it's not <a href="kiosk-extensions/extensions-api/./disabling-and-removing.html">disabled</a>, it can access protected functions. The following example shows how to access the <code>place</code> function:</p>
<pre><code class="language-Move">module examples::letterbox_ext {
    // ...

    /// Emitted when trying to place an item without permissions.
    const ENotEnoughPermissions: u64 = 1;

    /// Place a letter into the Kiosk without the KioskOwnerCap.
    public fun place(kiosk: &amp;mut Kiosk, letter: Letter, policy: &amp;TransferPolicy&lt;T&gt;) {
        assert!(kiosk_extension::can_place&lt;Extension&gt;(kiosk), ENotEnoughPermissions)

        kiosk_extension::place(Extension {}, kiosk, letter, policy)
    }
}
</code></pre>
<p>Currently, two functions are available:</p>
<ul>
<li><code>place&lt;Ext, T&gt;(Ext, &amp;mut Kiosk, T, &amp;TransferPolicy&lt;T&gt;)</code> - similar to <a href="kiosk-extensions/extensions-api/./../../kiosk/place-and-take.html">place</a></li>
<li><code>lock&lt;Ext, T&gt;(Ext, &amp;mut Kiosk, T, &amp;TransferPolicy&lt;T&gt;)</code> - similar to <a href="kiosk-extensions/extensions-api/./../../kiosk/locking.html">lock</a></li>
</ul>
<h2><a class="header" href="#checking-permissions" id="checking-permissions">Checking permissions</a></h2>
<p>The <code>can_place&lt;Ext&gt;(kiosk: &amp;Kiosk): bool</code> function can be used to check if the extension has the <code>place</code> permission. The <code>can_lock&lt;Ext&gt;(kiosk: &amp;Kiosk): bool</code> function can be used to check if the extension has the <code>lock</code> permission. Both functions make sure that the Extension is enabled, so an explicit check for that is not needed.</p>
<h1><a class="header" href="#extension-storage" id="extension-storage">Extension Storage</a></h1>
<p>Every extension gets its isolated storage which can be accessed only by the extension module (providing the Extension Witness). It's a <a href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/bag.move"><code>Bag</code></a>. Once an extension is installed, it can use the storage to store its data. Ideally, the storage should be managed in a way that allows the extension to be removed from the Kiosk if there are no active trades or other activities happening at the moment.</p>
<blockquote>
<p>The storage is always available to the extension if it is installed. Kiosk Owner can't access the storage of the extension if the logic for it is not implemented.</p>
</blockquote>
<h2><a class="header" href="#accessing-the-storage" id="accessing-the-storage">Accessing the storage</a></h2>
<p>An installed extension can access the storage mutably or immutably using one of the following functions:</p>
<ul>
<li><code>storage(_ext: Extension {}, kiosk: &amp;Kiosk): Bag</code>: returns a reference to the storage of the extension. Can be used to read the storage.</li>
<li><code>storage_mut(_ext: Extension {}, kiosk: &amp;mut Kiosk): &amp;mut Bag</code>: returns a mutable reference to the storage of the extension. Can be used to read and write to the storage.</li>
</ul>
<h1><a class="header" href="#disabling-and-removing" id="disabling-and-removing">Disabling and Removing</a></h1>
<p>Any extension can be disabled by the Kiosk Owner at any time. This will revoke all permissions of the extension and prevent it from performing any actions in the Kiosk. The extension can be re-enabled at any time by the Kiosk Owner.</p>
<blockquote>
<p>Disabling an extension does not remove it from the Kiosk. An installed Extension has access to its storage until completely removed from the Kiosk.</p>
</blockquote>
<h2><a class="header" href="#disabling-an-extension" id="disabling-an-extension">Disabling an extension</a></h2>
<p>The <code>disable&lt;Ext&gt;(kiosk: &amp;mut Kiosk, cap: &amp;KioskOwnerCap)</code> function can be used to disable an extension. It will revoke all permissions of the extension and prevent it from performing any protected actions in the Kiosk.</p>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">let txb = new TransactionBuilder();
let kioskArg = tx.object('&lt;ID&gt;');
let capArg = tx.object('&lt;ID&gt;');

txb.moveCall({
    target: '0x2::kiosk_extension::disable',
    arguments: [ kioskArg, capArg ],
    typeArguments: '&lt;letter_box_package&gt;::letterbox_ext::Extension'
});
</code></pre>
<h2><a class="header" href="#removing-an-extension" id="removing-an-extension">Removing an extension</a></h2>
<p>An extension can be removed only <strong>if the storage is empty</strong>. The <code>remove&lt;Ext&gt;(kiosk: &amp;mut Kiosk, cap: &amp;KioskOwnerCap)</code> function can be used to remove an extension. It will remove the extension, unpack the extension storage and configuration and rebate the storage cost to the Kiosk Owner. Can only be performed by the Kiosk Owner.</p>
<p>The call will fail if the storage is not empty.</p>
<p><strong>Example PTB</strong></p>
<pre><code class="language-js">let txb = new TransactionBuilder();
let kioskArg = tx.object('&lt;ID&gt;');
let capArg = tx.object('&lt;ID&gt;');

txb.moveCall({
    target: '0x2::kiosk_extension::remove',
    arguments: [ kioskArg, capArg ],
    typeArguments: '&lt;letter_box_package&gt;::letterbox_ext::Extension'
});
</code></pre>
<h1><a class="header" href="#building-with-kiosk" id="building-with-kiosk">Building with Kiosk</a></h1>
<h1><a class="header" href="#indexing-events" id="indexing-events">Indexing Events</a></h1>
<h1><a class="header" href="#using-kiosk-in-a-module" id="using-kiosk-in-a-module">Using Kiosk in a Module</a></h1>
<h1><a class="header" href="#custom-event-handlers-in-extensions" id="custom-event-handlers-in-extensions">Custom Event handlers in Extensions</a></h1>
<h1><a class="header" href="#demo-applications" id="demo-applications">Demo Applications</a></h1>
<h1><a class="header" href="#mysten-kiosk" id="mysten-kiosk">Mysten Kiosk</a></h1>
<p>Kiosk is a flexible base for building commerce-related applications on top of it. And as such it's
not providing any specifics in the implementation. However, we offer a set of extensions and rules
which cover the most common use cases.</p>
<p>Mysten Kiosk package contains rules and extensions and aims to be a swiss-army knife for onchain
commerce. The package is being developed and upgraded regularly to make sure there's a solution for
most of the common use cases.</p>
<h2><a class="header" href="#repository-and-code" id="repository-and-code">Repository and Code</a></h2>
<p>Code is located in the <a href="https://github.com/MystenLabs/apps">MystenLabs/apps</a> repository. It features
the sources and instructions on how to add them to your project on both <code>mainnet</code> and <code>testnet</code>
environments.</p>
<h2><a class="header" href="#extensions-1" id="extensions-1">Extensions</a></h2>
<ul>
<li><a href="mysten-kiosk/./extensions/personal-kiosk.html">Personal Kiosk Extension</a> makes the Kiosk non-transferrable and locks it to
the owner. This allows creators to check whether their assets are traded in a user-owned Kiosk or
whether it's a custom Kiosk-based solution (which may allow Kiosk trading - a way to escape policy
enforcement).</li>
</ul>
<h2><a class="header" href="#rules-1" id="rules-1">Rules</a></h2>
<ul>
<li>
<p><a href="mysten-kiosk/./rules/royalty-rule.html">Royalty Rule</a> allows creators to set a royalty fee for every trade of their
assets. The fee is paid to the creator on every trade. Not only does it add a percentage-based fee
to the trade, but it also allows setting a <code>min_price</code> - a minimum fee paid for the asset (for
trades below a certain threshold).</p>
</li>
<li>
<p><a href="mysten-kiosk/./rules/kiosk_lock_rule.html">Kiosk Lock Rule</a> allows creators to <a href="mysten-kiosk/../kiosk/locking.html">lock</a> their
assets in a Kiosk disabling the <a href="mysten-kiosk/../kiosk/place-and-take.html">&quot;take&quot; operation</a>.</p>
</li>
<li>
<p><a href="mysten-kiosk/./rules/personal-kiosk.html">Personal Kiosk Rule</a> allows creators to enable trades only between personal
Kiosks. Enforces the <a href="mysten-kiosk/./extensions/personal-kiosk.html">Personal Kiosk Extension</a> on the buyer's side.</p>
</li>
<li>
<p><a href="mysten-kiosk/./rules/floor-price-rule.html">Floor Price Rule</a> allows creators to set a minimum price for their assets
in a Kiosk. The rule enforces the minimum price setting on the seller's side.</p>
</li>
</ul>
<h2><a class="header" href="#sdk" id="sdk">SDK</a></h2>
<p>Mysten Kiosk package is fully supported by the
<a href="https://www.npmjs.com/package/@mysten/kiosk">Kiosk SDK @mysten/kiosk</a>, which provides handy
functions to perform actions in a Kiosk and resolve <code>TransferRequest</code>s.</p>
<h1><a class="header" href="#extensions-2" id="extensions-2">Extensions</a></h1>
<h1><a class="header" href="#personal-kiosk" id="personal-kiosk">Personal Kiosk</a></h1>
<h1><a class="header" href="#rules-2" id="rules-2">Rules</a></h1>
<h1><a class="header" href="#royalty-rule" id="royalty-rule">Royalty Rule</a></h1>
<h1><a class="header" href="#kiosk-lock-rule" id="kiosk-lock-rule">Kiosk Lock Rule</a></h1>
<h1><a class="header" href="#personal-kiosk-rule" id="personal-kiosk-rule">Personal Kiosk Rule</a></h1>
<h1><a class="header" href="#witness-rule" id="witness-rule">Witness Rule</a></h1>
<h1><a class="header" href="#floor-price-rule" id="floor-price-rule">Floor Price Rule</a></h1>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>This section contains additional, mostly technical materials which can be used as a reference when using or building an application utilizing Kiosk. </p>
<h1><a class="header" href="#appendix-a-glossary" id="appendix-a-glossary">Appendix A: Glossary</a></h1>
<ul>
<li>
<p><strong>Kiosk</strong> - a single Kiosk object that stores assets and their states, and profits from sales; protects the contents, the only party that can access and change the state is <strong>Kiosk Owner</strong>.</p>
</li>
<li>
<p><strong>Kiosk Owner</strong> - a party that owns the <code>KioskOwnerCap</code> - can be an application (represented as an object) or a single account</p>
</li>
<li>
<p><strong>TransferPolicy</strong> - an object that authorizes <code>TransferRequest</code>s, by default requires no actions but can be modified by adding Rules. TransferPolicy is controlled by the <strong>Creator</strong>, and can only receive payments and approve TransferRequests.</p>
</li>
<li>
<p><strong>Transfer Request</strong> - a temporary non-discardable struct (Hot Potato) created on every purchase operation in Kiosk. Must be resolved at a matching <strong>TransferPolicy</strong> for the transaction to succeed. If a policy has <strong>Rules</strong>, each of the rules must add a <strong>Rule Receipt</strong> to the TransferRequest before the confirmation.</p>
</li>
<li>
<p><strong>Creator</strong> - a party that owns the <code>TransferPolicyCap</code> - an object that grants full access to the TransferPolicy. Can be both an application (represented as an object) and a single account. </p>
</li>
<li>
<p><strong>Rule</strong> - a single requirement in a <strong>TransferPolicy</strong> represented as a module with a unique witness type and a function to “satisfy the rule” and add a receipt in the TransferRequest.</p>
</li>
<li>
<p><strong>Rule Receipt</strong> - a “stamp” put into a <strong>TransferRequest</strong> by presenting a witness (instance of a droppable struct); receipts in the TransferRequest are compared against <strong>Rules</strong> added to the <strong>TransferPolicy</strong>, and if they match, a request can be confirmed.</p>
</li>
</ul>
<h1><a class="header" href="#appendix-b-asset-states-in-kiosk" id="appendix-b-asset-states-in-kiosk">Appendix B: Asset States in Kiosk</a></h1>
<p>An asset in Kiosk can be in one of the following states:</p>
<ul>
<li>Placed</li>
<li>Locked (special case of Placed)</li>
<li>Listed</li>
<li>Listed Exclusively</li>
</ul>
<h2><a class="header" href="#placed" id="placed">Placed</a></h2>
<p>Asset is put into the Kiosk by the <a href="appendix/">Kiosk Owner</a> using the <a href="appendix/../kiosk/place-and-take"><code>kiosk::place</code></a> function. An owner can perform any available action on an item in this state.</p>
<h3><a class="header" href="#available-actions" id="available-actions">Available actions</a></h3>
<ul>
<li><a href="appendix/../kiosk/place-and-take">take</a> </li>
<li><a href="appendix/../kiosk/list-and-purchase">list</a></li>
<li><a href="appendix/../kiosk/borrowing">borrow</a></li>
<li><a href="appendix/../kiosk/borrowing">borrow_mut</a></li>
<li><a href="appendix/../kiosk/borrowing">borrow_val</a></li>
</ul>
<h3><a class="header" href="#check-state" id="check-state">Check state</a></h3>
<p>To check that asset is in the right state, the caller can use <code>is_placed</code> function, however, to make sure that the asset is not <em>locked</em>, we need to check <code>!is_locked</code>.</p>
<pre><code class="language-Move">let is_placed = kiosk::is_placed&lt;T&gt;(&amp;Kiosk, ItemID) &amp;&amp; !kiosk::is_locked&lt;T&gt;(&amp;Kiosk, ItemID);
</code></pre>
<h2><a class="header" href="#locked" id="locked">Locked</a></h2>
<p>Asset can also be placed and <em>locked</em> in a Kiosk using the <a href="appendix/../kiosk/locking"><code>kiosk::lock</code></a> function. Unlike <em>place</em>, locking mechanic disables taking. </p>
<h3><a class="header" href="#available-actions-1" id="available-actions-1">Available actions</a></h3>
<ul>
<li><a href="appendix/../kiosk/list-and-purchase">list</a> - change state to Listed</li>
<li><a href="appendix/../kiosk/purchase-cap">list with PurchaseCap</a> - change state to Listed Exclusively</li>
<li><a href="appendix/../kiosk/borrowing">borrow</a></li>
<li><a href="appendix/../kiosk/borrowing">borrow_mut</a></li>
<li><a href="appendix/../kiosk/borrowing">borrow_val</a></li>
</ul>
<h3><a class="header" href="#check-state-1" id="check-state-1">Check state</a></h3>
<p>Kiosk has a built in <code>is_locked</code> function to check if the item is locked.</p>
<pre><code class="language-Move">let is_locked = kiosk::is_locked&lt;T&gt;(&amp;Kiosk, ItemID);
</code></pre>
<h2><a class="header" href="#listed" id="listed">Listed</a></h2>
<p>A placed or a locked item can be listed using the <a href="appendix/../kiosk/list-and-purchase"><code>list</code></a> function. The asset then becomes publicly available for purchase. </p>
<blockquote>
<p>While listed, an asset can not be modified.</p>
</blockquote>
<h3><a class="header" href="#available-actions-2" id="available-actions-2">Available actions</a></h3>
<ul>
<li><a href="appendix/../kiosk/list-and-purchase">purchase</a> - move the asset out of the Kiosk</li>
<li><a href="appendix/../kiosk/list-and-purchase">delist</a> - return to the previous state: Placed or Locked</li>
<li><a href="appendix/../kiosk/borrowing">borrow</a></li>
</ul>
<h3><a class="header" href="#check-state-2" id="check-state-2">Check state</a></h3>
<p>To check if the item is listed, use <code>is_listed</code> function.</p>
<pre><code class="language-Move">let is_listed = kiosk::is_listed&lt;T&gt;(&amp;Kiosk, ItemID)
</code></pre>
<h2><a class="header" href="#listed-exclusively" id="listed-exclusively">Listed Exclusively</a></h2>
<p>When an asset is listed using the <a href="appendix/../kiosk/purchase-cap"><code>list_with_purchase_cap</code></a>, it gets “listed exclusively” state. While in this state, an asset is available for purchase to the owner of the <code>PurchaseCap</code>, and cannot be delisted unless the <code>PurchaseCap</code> is returned.</p>
<blockquote>
<p>While listed exclusively, an asset can not be modified.</p>
</blockquote>
<h3><a class="header" href="#available-actions-3" id="available-actions-3">Available actions</a></h3>
<ul>
<li><a href="appendix/../kiosk/purchase-cap.html">purchase with PurchaseCap</a> - move the asset out of the Kiosk</li>
<li><a href="appendix/../kiosk/purchase-cap.html">return PurchaseCap</a> - return to the previous state: Placed or Locked</li>
<li><a href="appendix/../kiosk/borrowing.html">borrow</a></li>
</ul>
<h3><a class="header" href="#check-state-3" id="check-state-3">Check state</a></h3>
<p>To check if an asset is listed exclusively, use <code>is_listed_exclusively</code> function.</p>
<pre><code class="language-Move">let is_listed_exclusively = kiosk::is_listed_exclusively&lt;T&gt;(&amp;Kiosk, ItemID);
</code></pre>
<h1><a class="header" href="#appendix-c-extension-states" id="appendix-c-extension-states">Appendix C: Extension States</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
